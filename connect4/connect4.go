package connect4

import (
	"github.com/jonathangray92/distributed-minimax/game"
	"fmt"
	"bytes"
	"encoding/gob"
)

// Implements game.State for connect 4
// X and Y are bitmasks where the lowest 42 bits correspond to the 42 positions
// on a connect 4 board. Bit 0 is the top-left spot, and bit 41 is the bottom-
// right spot
type State struct {
	X, Y uint64
	IsXMove bool
}

// Helper function which returns the starting connect4 state
func NewInitialState() *State {
	return &State{X: 0, Y: 0, IsXMove: true}
}

// Hard-coded bitmasks of all four-in-a-row positions on a connect 4 board
// Generated by winmasks.py
var winMasks = [...]uint64 {
	15,30,60,120,1920,3840,7680,15360,245760,491520,983040,1966080,31457280,62914560,125829120,251658240,4026531840,8053063680,16106127360,32212254720,515396075520,1030792151040,2061584302080,4123168604160,2113665,4227330,8454660,16909320,33818640,67637280,135274560,270549120,541098240,1082196480,2164392960,4328785920,8657571840,17315143680,34630287360,69260574720,138521149440,277042298880,554084597760,1108169195520,2216338391040,16843009,33686018,67372036,134744072,2155905152,4311810304,8623620608,17247241216,275955859456,551911718912,1103823437824,2207646875648,17043520,8521760,4260880,2130440,2181570560,1090785280,545392640,272696320,279241031680,139620515840,69810257920,34905128960,
}

// Checks for win conditions and performs heuristic calculation
//
// If X / Y has won, returns game.MaxValue / game.MinValue
//
// If nobody has won, returns a heuristic value calculated as follows:
// - let XP be the number of four-in-a-row spots in which X has >=1 piece
// - let YP be the number of four-in-a-row spots in which Y has >=1 piece
// - the heuristic value = XP - YP
// Note that the four-in-a-row spots where both X and Y have a piece cancel out
// and we are left with the difference in the number of possible win spots
func (s *State) Value() game.Value {
	xPartials := 0
	yPartials := 0
	for _, mask := range winMasks {
		xMasked := s.X & mask
		yMasked := s.Y & mask
		// check for win conditions
		if xMasked == mask {
			return game.MaxValue
		} else if yMasked == mask {
			return game.MinValue
		}
		// modify heuristic value
		if xMasked != 0 { xPartials += 1 }
		if yMasked != 0 { yPartials += 1 }
	}
	// nobody wins: return heuristic value
	return game.Value(xPartials - yPartials)
}

// X is the maximizing player, and Y is the minimizing player
func (s *State) MaximizingPlayer() bool {
	return s.IsXMove
}

func (s *State) MoveIterator() game.StateIterator {
	// return empty move iterator if someone already won
	value := s.Value()
	if value == game.MinValue || value == game.MaxValue {
		return func() game.State { return nil }
	}

	column := uint(0)
	return func() game.State {
		for column < 7 {
			// a bit ugly; we need to ensure that column is incremented whether
			// or not we return. Just increment it now and return (column - 1)
			column += 1
			if !s.isColumnFull(column-1) {
				return s.makeMove(column-1)
			}
		}
		return nil
	}
}

// Use gob encoding because I'm lazy
func (s *State) EncodeState() ([]byte, error) {
	var buf bytes.Buffer
	err := gob.NewEncoder(&buf).Encode(s)
	if err != nil { return nil, err }
	return buf.Bytes(), nil
}

// Use gob encoding because I'm lazy
func (s *State) DecodeState(p []byte) error {
	return gob.NewDecoder(bytes.NewBuffer(p)).Decode(s)
}

// Utility function to print a board state to stdout
func (s *State) PrintState() {
	for c := 0; c < 42; c += 1 {
		// separate lines rows
		if c % 7 == 0 {
			fmt.Printf("\n|")
		}
		// generate mask
		m := uint64(1 << uint(c))
		// print board positions
		if s.X & m != 0 {
			fmt.Printf("X|")
		} else if s.Y & m != 0 {
			fmt.Printf("O|")
		} else {
			fmt.Printf(" |")
		}
	}
	fmt.Printf("\n")
}

// Use the struct itself as a unique hash value
func (s *State) Id() interface{} { return *s }

// Helper function which checks if a column is full
// A return value of false means that a move can be made in that column
func (s *State) isColumnFull(column uint) bool {
	return (s.X | s.Y) & (1 << column) != 0
}

// Helper function which makes a move by dropping a piece into the given column
// DOES NOT check that the column is not already full! Assumes the caller
// checked.
func (s *State) makeMove(column uint) *State {

	// calculate which spots are occupied by either player
	occupied := s.X | s.Y

	// start at the bottom row, move up until a free spot is found
	// m is a one-hot mask of spot candidates
	for m := uint64(1 << (35 + column)); ; m >>= 7 {
		if occupied & m == 0 {
			// empty spot found; make move
			if s.IsXMove {
				return &State{IsXMove: false, X: s.X | m, Y: s.Y}
			} else {
				return &State{IsXMove: true, X: s.X, Y: s.Y | m}
			}
		}
	}
}
